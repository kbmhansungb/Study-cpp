#pragma once

/*

https://programmers.co.kr/learn/courses/30/lessons/42626
19:25 더 맵게 시작
19:31 디버그 시작
19:35 종료

https://programmers.co.kr/learn/courses/30/lessons/77485
18:21 행렬 테두리 시작
18:42 아이고야,, 알고리즘 잘못짬.
18:55 디버그 시작
19:19 길어지니 겁나 길어짐. 나눠서 정복하자,,

https://programmers.co.kr/learn/courses/30/lessons/12899
17:39 124 나라의 숫자 시작
17:52 디버그 시작
18:08 이론 부족.
18:14 완료

https://programmers.co.kr/learn/courses/30/lessons/1835
16:34 단체사진 찍기 시작
16:46 조합 생성에서 잠시 막힘
17:12 디버그 시작
17:23 완료.
// 이번엔 컨디션 분화에서 막힘.
// 평균적으로 알고리즘 짜는데 40분 걸리는거 같다. 더 빨리 짤 수 있는 방법이 있는가?
int perm[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
while (next_permutation(perm, perm + 8));
// 다음번 조합이 가능한 이상, 계속해서 조합을 만든다...
https://twpower.github.io/82-next_permutation-and-prev_permutation
// 이런 메서드가 있었네,
// 조합문제는 이 메서드를 이용하여 재귀함수를 없앨 수 있다...

https://programmers.co.kr/learn/courses/30/lessons/1829
2021 11 25
15:00 카카오 프렌즈 커러링북 시작
15:04 문제 이해하고 풀이 방법 세움
15:30 쓸데없는 고민좀 하다가 디버그에 들어감.
15:35 코드가 직관적이고, 유연하면서 쓸데없는 리소스(스텍, 힙) 안만드는 법,, 만들기 어렵네,
15:40 다시 디버깅 시작
15:45 디버깅 종료, 적용 시작
15:54 종료
// 결론 현재 Level2를 푸는데 50 ~ 60분 정도 걸린다.. 이게 말이 되냐. 슬퍼어
// 정리. 인덱스를 관리하는 법, 분화, 종료조건에서 시간 에서 시간을 많이 잡아먹음.

https://programmers.co.kr/learn/courses/30/lessons/60057
2021 11 25
14:13 문자열 압축 시작
14:37 알고리즘 초안 작성.. 하지만 오류있음.
14:40 디버그 끝. 인덱스의 증가부분에서 오류가 있었음.
14:47 두번째 오류 발견,,
14:54 디버그 끝. 여전히 이터레이터 처럼 쓰는 인덱스 증가부분에서 있었음.
14:56 알고리즘에 문제 있음.. 이해 안되는 조건있음.
14:58 종료

*/