#pragma once

/*

	https://programmers.co.kr/learn/courses/30/lessons/42895

	1. 1부터 8까지 사용하는 num의 숫자를 증가시키면서, 테스트한다.
	2. 가능한 경우가 없으면 -1을 리턴한다.

	2021-12-05

	13:50 풀기 시작
	14:40 적당한 알고리즘으로 푸는 것이 핵심인가,, 수학적 증명은 엄청 오래 걸린다.
	16:38 다음에 다시풀자.. 머리 터질거 같네,
*/


////// 괄호를 정리하기
// { i } 를 초기치로 두었을 때.
// 원하는 반복문은 다음과 같다.
// i n씩 감소했을 때, 가능한 경우의 수는 다음과 같다.
// n = 0 -> 1 : { i }
// n = 1 -> 1 : { i - 1, 1 }										
// n = 2 -> 2 : { i - 2, 2 }, { i - 2, 1, 1 }					
// n = 3 -> 4 : { i - 3, 3 }, { i - 3, 2, 1 }, { i - 3, 1, 2 }, { i - 3, 1, 1, 1 }
// n = 4 -> 8 : { i - 4, 4 }, { i - 4, 3, 1 }, { i - 4, 2, 2 }, { i - 4, 2, 1, 1 }, { i - 4, 1, 3 }, { i - 4, 1, 2, 1 }, { i - 4, 1, 2 }, { i - 4, 1, 1, 1 }
// ...

// i값이 주어질 때, 가능한 n과 n으로 인해 가능한 조합의 수는,
// i = 1 -> 0			-> 1				1
// i = 2 -> 0, 1		-> 1 + 1			2
// i = 3 -> 0, 1, 2		-> 1 + 1 + 2		4
// i = 4 -> 0, 1, 2, 3	-> 1 + 1 + 2 + 4 	8
//

// 솔직히,, 현재 나의 뇌수준으로 괄호와 연산을 구하면서 중복을 제거할 수 없으니,, 중복되도 그냥 쓰자.

////// 연산을 정리하기
// { 1 } 이 들어왔을 때, 가능한 연산 조합은 5 하나이다. 이를 정리하면
// { 1 } : 5
// { 2 } : 5 + 5 = 10, 5 - 5 = 0, 5 * 5 = 25, 5 / 5 = 1, 5 _ 5 = 55
//		 : 10, 0, 25, 1, 55 -> 5개
// { 3 } : 5 + 5 + 5, 5 + 5 - 5 ...
//		 : 5 * 5 -> 25개가 가능하다.

////// 가능한 경우의 수 크기
// i = 1 -> { 1 } ->  5^(1-1) -> 5^0 = 1
// i = 2 -> { 2 }, { 1, 1 } -> 5^(2-1) + 5^(1-1)*5^(1-1) = 5 + 1 = 6
// i = 3 -> { 3 }, { 2, 1 }, { 1, 2 }, { 1, 1, 1 } -> 25 + 6 + 6 + 1 = 38
// i = 4 -> { 4 }, { 3, 1 }, { 2, 2 }, { 2, 1, 1 }, { 1, 3 }, { 1, 2, 1 }, { 1, 1, 2 }, { 1, 1, 1 } -> 125 + 38 + 6*6 + 38 + ??? 이렇게 할 필요 없나..


#include <vector>
#include <set>
using namespace std;
int solution(int N, int number) {
	if (N == number)
		return 1;
	
	vector<set<int>> vaild_num(8);
	vaild_num[0].insert(5);
	/*
		f(i, N) 연산을 정의하면 ?는 +, -, *, /
		i = 1 : { N }
		i = 2 : { NN, N?N }
		i = 3 : { NNN, N?N?N, (N?N)?N, N?(N?N) }
			(N?N) = f(2)
			  : { NNN, N?N?N, f(2)?N, N?f(2) }
			f(2)?N - N?f(2) = { f(2)_N, f(2)+N, f(2)-N, f(2)*N, f(2)/N } - { N_f(2), N+f(2), N-f(2), N*f(2), N/f(2) }
							= { f(2)-N, f(2)/N }
			  : { NNN, N?N?N, N?f(2), f(2)-N, f(2)/N }
			N?N?N - N?f(2) = N?N?N - N?{ NN, N?N }
						   = N?N?N - N?NN - N?(N?N)

		i = 4 : { NNNN,  }
	*/
	// 1. 1부터 8까지 사용하는 num의 숫자를 증가시키면서, 테스트한다.
	for (int i = 2; i <= 8; ++i)
	{
	}
	// 2. 가능한 경우가 없으면 - 1을 리턴한다.
	return -1;
}