#pragma once

/*

 동시성 구성요소들
 과제, 미래, 스레드, 뮤텍스, 조건 변수, 원자적 객체 등등...

*/

/*
	doAsyncWork라는 함수를 비동기적으로 실행한다고 하자. 방법은 크게 두 가지이다.

	하나는 std::thread 객체를 생성해서 그 객체에서 do AsyncWork를 실행하는 것이다. 
	이를 스레드 기반(thread_based)프로그래밍이라 한다.

	int doAsyncWork();
	std::thread t(doAsyncWork);

	다른 하나는 doAsyncWork를 std::async에 넘겨주는 것이다. 이를 과제 기반(task_based)
	프로그래밍이라 한다.

	auto fut = std::async(doAsyncWork); // fut은 future를 뜻함.

	대체로 과제 기반 접근 방식이 스레드 기반 접근 방식보다 우월하다.
	스레드 기반 호출에서는 그 반환값에 접근할 방법이 이벗다.
	반면 과제 기반 접근방식에서는 get함수를 이용하여 간단하게 접근 할 수 있다.

	스레드 기반 프로그래밍과 과제 기반 프로그래밍의 좀더 근본적인 차이는,
	과제 기반 접근방식은 좀 더 높은 수준의 추상을 체현한다는 점이다.

	{
		c++ 소프트웨어에서 스레드라는 용어가 세가지 의미로 쓰인다.
		실제 계산을 수행하는 스레드를 뜻하는 하드웨어 스레드,
		운영체제가 하드웨어 스레들에서 실행되는 모든 프로세서와 일정을 관리하는데 사용하는 소프트웨어 스레드, OS 스레드나 시스템 스레드,
		(대체로 하드웨어 스레드보다 많은 소프트웨어 스레드를 생성할 수 있다. 스레드가 차단되어 있어도 차단되어 있지 않은 스레드를 처리하여 성능 향상을 기대할 수 있기 때문에)
		c++ 표준 라이브러리의 std::thread. 하나의 c++프로세스 안에서 std::thread 객체는 바탕 소프트웨어 스레드에 대한 핸들로 작용한다.
	}

	소프트웨어 스레드는 제한된 자원이다. 시스템이 제공할 수 있는 것보다 많은 소프트웨어 스레드를 생성하면 시스템 에러를 발생한다.
	noexcept와는 상관없이,

	잘 작성된 소프트웨어는 이런 가능성을 어떻게든 처리해야 한다. 그렇다면,
	소프트웨어 스레드가 부족한 상황을 어떻게 처리해야 할까?
	한가지 접근방식은 doAsyncWork를 그냥 현재 스레드에서 실행하는 것이지만,
	그러면 현재 스레드에 부하(load)가 과중하게 걸리 수 있다.
*/