#pragma once
#include <iostream>

class Widget
{
public:
    // 기본 생성자
    // 클래스에 사용자 선언 생성자가 없는 경우에 자동적으로 생성된다.
    // 여기서는 선언했으므로 실제로 이 생성자는 기본 생성자가 아니다.
    Widget()
    {

    }
    // 기본 소멸자
    // 소멸자는 기본적으로 noexcept며 기반 클래스의 소멸자가 가상일 경우 소멸자 또한 가상이다.
    //~Widget()
    //{
    //}

    // 복사 생성자
    // 비정적 자료 멤버들을 멤버별로 복사 생성,
    // 클래스에 사용자 선언 복사 생성자가 없을 때에만 자동으로 작성
    // 클래스에 이동 연산이 하나라도 선언되어 있으면 삭제된다.
    // 사용자 선언 복사 배정 연산자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비권장이다.
    Widget(const Widget& other)
    {

    }
    // 복사 배정 연산자
    // 비정적 자료 멤버들을 멤버별로 복사 배정
    // 선언 복사 배정 연산자가 없을 때에만 자동으로 작성
    // 클래스에 이동 연산이 하나라도 선언되어 있으면 삭제
    // 사용자 선언 복사 생성자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비궈장
    Widget& operator=(const Widget& other)
    {
        Widget w; // 기본생성자로 생성된다.
        return w; // 대입이 이미 예정되어 있기 때문에 이동 생성자를 호출 하지 않는다.
    }

    // 이동 생성자, 이동 배정 연산자
    // 각각 비정적 자료 멤버의 멤버별 이동을 수행 (스텍에 선언된 것을 옮긺)
    // 클래스에 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을 때에만 자동으로 작성

    // 이동 생성자
    Widget(Widget&& widget) noexcept
    {

    }
    // 이동 배정 연산자
    Widget& operator=(Widget&& rhs) noexcept
    {
        Widget w; // 이동 배정 연산자에서는 기본 생성자로 생성한 후 바로 대입하게 된다.
        return w; // 대입이 이미 예정되어 있기 때문에 이동 생성자를 호출 하지 않는다.
    }
};

Widget return_w()
{
    Widget w; // 기본 생성자로 w가 생성된다.
    return w; // 이동 생성자로 w를 반환한다.
}

int main()
{
    Widget w;               // 기본 생성자로 생성된다.
    Widget n = w;           // 복사 생성자로 생성된다.
    Widget z = return_w();  // 반환 값은 이미 이동생성자이기 때문에 z에 대입된다.

    n = w;                  // l-value이기 때문에 복사 배정 연산자가 호출된다.
    n = return_w();         // r-value이기 때문에 이동 배정 연산자가 호출된다.
}