#pragma once

/*

	https://sckllo7.tistory.com/entry/32bit%EC%99%80-64bit%EC%9D%98-C-%EC%9E%90%EB%A3%8C%ED%98%95Data-Type-%ED%81%AC%EA%B8%B0-%EC%B0%A8%EC%9D%B4

	---------------------------------------------------------------------------------------------

	 CPU 와 컴퓨터 메모리인 RAM 은 물리적으로 떨어져 있습니다. 따라서 CPU 가 메모리
	에서 데이터를 읽어 오기 위해서는 꽤 많은 시간이 걸립니다. 실제로, 인텔의 i7-6700 CPU 의 경우
	최소 42 사이클 정도 걸린다고 보시면 됩니다. CPU 에서 덧셈 한 번을 1 사이클에 끝낼 수 있는데,
	메모리에서 데이터 오는 것을 기다리느라, 42 번 덧셈을 연산할 시간을 놓치게 되는 것

	이는 CPU 입장에 굉장한 손해가 아닐 수 없습니다. 메모리에서 데이터 한 번 읽을 때 마다 42 사이클
	동안 아무것도 못한다니 말입니다

	---------------------------------------------------------------------------------------------

	 따라서 CPU 개발자들은, 이를 보완하기 위해 캐시(Cache) 라는 것을 도입하였습니다. 캐시란,
	CPU 칩 안에 있는 조그마한 메모리라고 보시면 됩니다. 여기서 중요한 점은 램과는 다르게 CPU
	에서 연산을 수행하는 부분이랑 거의 붙어 있다 싶이 해서, 읽기 / 쓰기 속도가 매우 빠르다는 점입
	니다.

	 CPU 가 특정한 주소에 있는 데이터에 접근하려 한다면, 일단 캐시에 있는지 확인한 후, 캐시에
	있다면 해당 값을 읽고, 없다면 메모리 까지 갔다 오는 방식으로 진행됩니다. 이렇게 캐시에 있는
	데이터를 다시 요청해서 시간을 절약하는 것을 Cache hit 이라과 하며 반대로 캐시에 요청한 데이
	터가 없어서 메모리 까지 갔다 오는 것을 Cache miss 라고 부릅니다.

	• 메모리를 읽으면 일단 캐시에 저장해놓는다.
	• 만일 캐시가 다 찼다면 특정한 방식에 따라 처리한다.

	 이 때 여기서 말하는 특정한 방식 은 CPU 마다 다른데, 대표적인 예로 가장 이전에 쓴(LRU - Least
	Recently Used) 캐시를 날려버리고 그 자리에 새로운 캐시를 기록하는 방식이 있습니다. 이 LRU
	방식의 가장 큰 특징으로는, 최근에 접근한 데이터를 자주 반복해서 접근한다면 매우 유리하다는
	점이 있습니다.

	

	CPU register(16b) -42- RAM(4gb)
	>>>
	CPU register(16b) -1- Cache(1kb) -42- RAM(4gb)

	#안의 숫자는 위의 예시들이다. 기기마다 다르다.

	---------------------------------------------------------------------------------------------

	for (int i = 0; i < 1000; i++) {
		for (int j = 0; j < 10000; j++) {
			s += data[j];
		}
	}

	for (int j = 0; j < 10000; i++) {
		for (int i = 0; i < 10000; i++) {
			s += data[j];
		}
	}

	무엇이 더 빠른가?

	 답은 두 번째 방식입니다. 왜냐하면 첫 번째 경우에서 data[0] 를 접근하는 것을 생각해봅시다.
	일단 첫 번째 루프에서 data[0] 는 캐시에 들어가게 됩니다. 하지만, CPU 캐시가 매우 작기
	때문에 j = 256 이 되었을 때 data[0] 는 캐시에서 사라지게 되지요 (1KB = 1024 byte = int
	256 개).
	따라서 i = 1 인 루프에서 data[0] 에 다시 접근했을 때 이미 data[0] 는 캐시에서 사라진
	이후기에 Cache Miss 가 발생하게 됩니다. 따지고 보면 data 원소의 모든 접근이 Cache Miss 가
	되서 느리겠지요.
	반면에 후자의 경우 data[0] 을 10000 번 연속으로 접근하므로, 처음에 접근할 때 빼고 나머지
	9999 번 접근이 Cache hit 이 되어서 빠르게 덧셈을 수행할 수 있게 됩니다.
	캐시에 대해서는 이 정도로 줄이겠습니다. 사실 캐시에 대해서만 이야기해도 한 보따리는 풀 수
	있지만, 이는 나중에 컴퓨터 시스템에 관한 강좌를 하게 되면다면 더 깊게 다루도록 하겠습니다.

	간단하게 보여주면,
	1번 : data[0], data[1], data[2], ...
	2번 : data[0], data[0], ... data[0], data[1], ...
	2번 방식이 더 빠르다.

*/